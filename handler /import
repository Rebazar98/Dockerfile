// server.js (sustituye SOLO el handler /import)
app.post('/import', upload.any(), async (req, res) => {
  const cleanup = (p) => { try { if (p && fs.existsSync(p)) fs.unlinkSync(p); } catch(_){} };

  try {
    // --- ENV PG ---
    const { PGHOST, PGPORT = '5432', PGDATABASE, PGUSER, PGPASSWORD } = process.env;
    if (!PGHOST || !PGDATABASE || !PGUSER || !PGPASSWORD) {
      return res.status(500).json({ error: 'Faltan variables PG* en entorno' });
    }

    // --- Params ---
    const b = req.body || {};
    let { sourceUrl, table = 'parcelas_muros', srid = 25830, promoteToMulti = 'true', layerName } = b;
    if (typeof promoteToMulti !== 'boolean') promoteToMulti = String(promoteToMulti).toLowerCase() === 'true';
    if (typeof srid === 'string') srid = parseInt(srid, 10);

    // --- Origen: binario (n8n) o URL ---
    let localPath, removeLocalAfter = false;
    const filePart = (req.files || []).find(f => f.fieldname === 'data') || (req.files || []).find(f => f.fieldname === 'file');

    if (filePart) {
      localPath = filePart.path;
      console.log(`[import] Binario recibido: ${filePart.originalname} ${filePart.mimetype} ${filePart.size}B`);
    } else if (sourceUrl) {
      const tmpDir = path.join(os.tmpdir(), 'gdal');
      fs.mkdirSync(tmpDir, { recursive: true });
      const rawName = path.basename((sourceUrl.split('?')[0] || '').split('#')[0]) || 'file.gml';
      localPath = path.join(tmpDir, rawName);
      const resp = await axios.get(sourceUrl, { responseType: 'arraybuffer', validateStatus: s => s >= 200 && s < 400 });
      const ct = (resp.headers['content-type'] || '');
      if (ct.includes('text/html')) {
        return res.status(400).json({ error: 'La URL devuelve HTML (login/antivirus). Envía el archivo como binario.' });
      }
      fs.writeFileSync(localPath, resp.data);
      removeLocalAfter = true;
      console.log(`[import] Descargado ${rawName} (${resp.data.length}B) CT=${ct}`);
    } else {
      return res.status(400).json({ error: 'Envía "sourceUrl" o un archivo (campo "data"/"file")' });
    }

    const ext = path.extname(localPath).toLowerCase();
    const srcForOgr = (ext === '.zip') ? `/vsizip/${localPath}` : localPath;
    const layerArg = layerName ? `"${layerName}"` : '';
    const promoteArg = promoteToMulti ? '-nlt PROMOTE_TO_MULTI' : '';
    const conn = `PG:"host=${PGHOST} port=${PGPORT} dbname=${PGDATABASE} user=${PGUSER} password='${PGPASSWORD}'"`;

    // Detectar si el dataset trae SRS; si no, usar -a_srs
    const checkCmd = `ogrinfo -ro -so -al "${srcForOgr}" ${layerArg}`;
    let hasSRS = false;
    try {
      const info = await new Promise((ok) => exec(checkCmd, { maxBuffer: 1024*1024*16 }, (_, out='') => ok(String(out))));
      hasSRS = /Layer SRS WKT|PROJCS|GEOGCS|EPSG/.test(info);
    } catch (_) {}

    const srsAssign = hasSRS ? '' : `-a_srs EPSG:${srid}`; // asigna SRS si falta
    const reproject = `-t_srs EPSG:${srid}`;                // y reprojecta/garantiza SRID destino

    const cmd =
      `ogr2ogr -f "PostgreSQL" ${conn} "${srcForOgr}" ${layerArg} ` +
      `-nln ${table} -lco GEOMETRY_NAME=geom ${promoteArg} ${srsAssign} ${reproject} -overwrite -progress`;

    console.log('[import] CMD =>', cmd);

    exec(cmd, { maxBuffer: 1024 * 1024 * 64, timeout: 180000 }, (err, stdout, stderr) => {
      if (removeLocalAfter) cleanup(localPath);
      const payload = { ok: !err, cmd, stdout: String(stdout || ''), stderr: String(stderr || '') };
      if (err) {
        console.error('[ogr2ogr:error]', payload.stderr || payload.stdout);
        return res.status(500).json({ error: 'ogr2ogr failed', ...payload });
      }
      return res.json(payload);
    });

  } catch (e) {
    return res.status(500).json({ error: e.message || 'error' });
  }
});
